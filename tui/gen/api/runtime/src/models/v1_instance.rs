/*
 * rill/runtime/v1/api.proto
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// V1Instance : Instance represents a single data project, meaning one set of code artifacts, one connection to an OLAP datastore (DuckDB, Druid), and one catalog of related metadata (such as reconciliation state). Instances are the unit of isolation within the runtime. They enable one runtime deployment to serve not only multiple data projects, but also multiple tenants. On local, the runtime will usually have just a single instance.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct V1Instance {
    #[serde(rename = "instanceId", skip_serializing_if = "Option::is_none")]
    pub instance_id: Option<String>,
    #[serde(rename = "environment", skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    #[serde(rename = "olapConnector", skip_serializing_if = "Option::is_none")]
    pub olap_connector: Option<String>,
    #[serde(rename = "repoConnector", skip_serializing_if = "Option::is_none")]
    pub repo_connector: Option<String>,
    #[serde(rename = "adminConnector", skip_serializing_if = "Option::is_none")]
    pub admin_connector: Option<String>,
    #[serde(rename = "aiConnector", skip_serializing_if = "Option::is_none")]
    pub ai_connector: Option<String>,
    #[serde(rename = "createdOn", skip_serializing_if = "Option::is_none")]
    pub created_on: Option<String>,
    #[serde(rename = "updatedOn", skip_serializing_if = "Option::is_none")]
    pub updated_on: Option<String>,
    #[serde(rename = "connectors", skip_serializing_if = "Option::is_none")]
    pub connectors: Option<Vec<models::V1Connector>>,
    #[serde(rename = "projectConnectors", skip_serializing_if = "Option::is_none")]
    pub project_connectors: Option<Vec<models::V1Connector>>,
    #[serde(rename = "variables", skip_serializing_if = "Option::is_none")]
    pub variables: Option<std::collections::HashMap<String, String>>,
    #[serde(rename = "projectVariables", skip_serializing_if = "Option::is_none")]
    pub project_variables: Option<std::collections::HashMap<String, String>>,
    #[serde(rename = "featureFlags", skip_serializing_if = "Option::is_none")]
    pub feature_flags: Option<std::collections::HashMap<String, bool>>,
    #[serde(rename = "annotations", skip_serializing_if = "Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,
    #[serde(rename = "embedCatalog", skip_serializing_if = "Option::is_none")]
    pub embed_catalog: Option<bool>,
    #[serde(rename = "watchRepo", skip_serializing_if = "Option::is_none")]
    pub watch_repo: Option<bool>,
}

impl V1Instance {
    /// Instance represents a single data project, meaning one set of code artifacts, one connection to an OLAP datastore (DuckDB, Druid), and one catalog of related metadata (such as reconciliation state). Instances are the unit of isolation within the runtime. They enable one runtime deployment to serve not only multiple data projects, but also multiple tenants. On local, the runtime will usually have just a single instance.
    pub fn new() -> V1Instance {
        V1Instance {
            instance_id: None,
            environment: None,
            olap_connector: None,
            repo_connector: None,
            admin_connector: None,
            ai_connector: None,
            created_on: None,
            updated_on: None,
            connectors: None,
            project_connectors: None,
            variables: None,
            project_variables: None,
            feature_flags: None,
            annotations: None,
            embed_catalog: None,
            watch_repo: None,
        }
    }
}

